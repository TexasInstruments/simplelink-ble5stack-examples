#
# Generated by erpcgen 1.7.4 on Thu Jun  3 17:44:56 2021.
#
# AUTOGENERATED - DO NOT EDIT
#

import erpc

# Enumerators data types declarations
# @brief Bluetooth Mesh Access Layer
# @defgroup bt_mesh_access Bluetooth Mesh Access Layer
# @ingroup bt_mesh
# @{
BT_MESH_ADDR_UNASSIGNED = 0
BT_MESH_ADDR_ALL_NODES = 65535
BT_MESH_ADDR_PROXIES = 65532
BT_MESH_ADDR_FRIENDS = 65533
BT_MESH_ADDR_RELAYS = 65534

BT_MESH_KEY_UNUSED = 65535
BT_MESH_KEY_DEV = 65534
BT_MESH_KEY_DEV_LOCAL = 65535
BT_MESH_KEY_DEV_REMOTE = 65533
BT_MESH_KEY_DEV_ANY = 65532

BT_MESH_MODEL_ID_CFG_SRV = 0
BT_MESH_MODEL_ID_CFG_CLI = 1
BT_MESH_MODEL_ID_HEALTH_SRV = 2
BT_MESH_MODEL_ID_HEALTH_CLI = 3

BT_MESH_MODEL_ID_GEN_ONOFF_SRV = 4096
BT_MESH_MODEL_ID_GEN_ONOFF_CLI = 4097
BT_MESH_MODEL_ID_GEN_LEVEL_SRV = 4098
BT_MESH_MODEL_ID_GEN_LEVEL_CLI = 4099
BT_MESH_MODEL_ID_GEN_DEF_TRANS_TIME_SRV = 4100
BT_MESH_MODEL_ID_GEN_DEF_TRANS_TIME_CLI = 4101
BT_MESH_MODEL_ID_GEN_POWER_ONOFF_SRV = 4102
BT_MESH_MODEL_ID_GEN_POWER_ONOFF_SETUP_SRV = 4103
BT_MESH_MODEL_ID_GEN_POWER_ONOFF_CLI = 4104
BT_MESH_MODEL_ID_GEN_POWER_LEVEL_SRV = 4105
BT_MESH_MODEL_ID_GEN_POWER_LEVEL_SETUP_SRV = 4106
BT_MESH_MODEL_ID_GEN_POWER_LEVEL_CLI = 4107
BT_MESH_MODEL_ID_GEN_BATTERY_SRV = 4108
BT_MESH_MODEL_ID_GEN_BATTERY_CLI = 4109
BT_MESH_MODEL_ID_GEN_LOCATION_SRV = 4110
BT_MESH_MODEL_ID_GEN_LOCATION_SETUPSRV = 4111
BT_MESH_MODEL_ID_GEN_LOCATION_CLI = 4112
BT_MESH_MODEL_ID_GEN_ADMIN_PROP_SRV = 4113
BT_MESH_MODEL_ID_GEN_MANUFACTURER_PROP_SRV = 4114
BT_MESH_MODEL_ID_GEN_USER_PROP_SRV = 4115
BT_MESH_MODEL_ID_GEN_CLIENT_PROP_SRV = 4116
BT_MESH_MODEL_ID_GEN_PROP_CLI = 4117
BT_MESH_MODEL_ID_SENSOR_SRV = 4352
BT_MESH_MODEL_ID_SENSOR_SETUP_SRV = 4353
BT_MESH_MODEL_ID_SENSOR_CLI = 4354
BT_MESH_MODEL_ID_TIME_SRV = 4608
BT_MESH_MODEL_ID_TIME_SETUP_SRV = 4609
BT_MESH_MODEL_ID_TIME_CLI = 4610
BT_MESH_MODEL_ID_SCENE_SRV = 4611
BT_MESH_MODEL_ID_SCENE_SETUP_SRV = 4612
BT_MESH_MODEL_ID_SCENE_CLI = 4613
BT_MESH_MODEL_ID_SCHEDULER_SRV = 4614
BT_MESH_MODEL_ID_SCHEDULER_SETUP_SRV = 4615
BT_MESH_MODEL_ID_SCHEDULER_CLI = 4616
BT_MESH_MODEL_ID_LIGHT_LIGHTNESS_SRV = 4864
BT_MESH_MODEL_ID_LIGHT_LIGHTNESS_SETUP_SRV = 4865
BT_MESH_MODEL_ID_LIGHT_LIGHTNESS_CLI = 4866
BT_MESH_MODEL_ID_LIGHT_CTL_SRV = 4867
BT_MESH_MODEL_ID_LIGHT_CTL_SETUP_SRV = 4868
BT_MESH_MODEL_ID_LIGHT_CTL_CLI = 4869
BT_MESH_MODEL_ID_LIGHT_CTL_TEMP_SRV = 4870
BT_MESH_MODEL_ID_LIGHT_HSL_SRV = 4871
BT_MESH_MODEL_ID_LIGHT_HSL_SETUP_SRV = 4872
BT_MESH_MODEL_ID_LIGHT_HSL_CLI = 4873
BT_MESH_MODEL_ID_LIGHT_HSL_HUE_SRV = 4874
BT_MESH_MODEL_ID_LIGHT_HSL_SAT_SRV = 4875
BT_MESH_MODEL_ID_LIGHT_XYL_SRV = 4876
BT_MESH_MODEL_ID_LIGHT_XYL_SETUP_SRV = 4877
BT_MESH_MODEL_ID_LIGHT_XYL_CLI = 4878
BT_MESH_MODEL_ID_LIGHT_LC_SRV = 4879
BT_MESH_MODEL_ID_LIGHT_LC_SETUPSRV = 4880
BT_MESH_MODEL_ID_LIGHT_LC_CLI = 4881

   #Length of a short Mesh MIC.
BT_MESH_MIC_SHORT = 4
   #Length of a long Mesh MIC.
BT_MESH_MIC_LONG = 8

   #Special TTL value to request using configured default TTL
BT_MESH_TTL_DEFAULT = 255
   #Maximum allowed TTL value
BT_MESH_TTL_MAX = 127

SIG_MODEL = 0
VND_MODEL = 1

   #No fault has occurred.
BT_MESH_HEALTH_FAULT_NO_FAULT = 0
   #health_faults.
BT_MESH_HEALTH_FAULT_BATTERY_LOW_WARNING = 1
BT_MESH_HEALTH_FAULT_BATTERY_LOW_ERROR = 2
BT_MESH_HEALTH_FAULT_SUPPLY_VOLTAGE_TOO_LOW_WARNING = 3
BT_MESH_HEALTH_FAULT_SUPPLY_VOLTAGE_TOO_LOW_ERROR = 4
BT_MESH_HEALTH_FAULT_SUPPLY_VOLTAGE_TOO_HIGH_WARNING = 5
BT_MESH_HEALTH_FAULT_SUPPLY_VOLTAGE_TOO_HIGH_ERROR = 6
BT_MESH_HEALTH_FAULT_POWER_SUPPLY_INTERRUPTED_WARNING = 7
BT_MESH_HEALTH_FAULT_POWER_SUPPLY_INTERRUPTED_ERROR = 8
BT_MESH_HEALTH_FAULT_NO_LOAD_WARNING = 9
BT_MESH_HEALTH_FAULT_NO_LOAD_ERROR = 10
BT_MESH_HEALTH_FAULT_OVERLOAD_WARNING = 11
BT_MESH_HEALTH_FAULT_OVERLOAD_ERROR = 12
BT_MESH_HEALTH_FAULT_OVERHEAT_WARNING = 13
BT_MESH_HEALTH_FAULT_OVERHEAT_ERROR = 14
BT_MESH_HEALTH_FAULT_CONDENSATION_WARNING = 15
BT_MESH_HEALTH_FAULT_CONDENSATION_ERROR = 16
BT_MESH_HEALTH_FAULT_VIBRATION_WARNING = 17
BT_MESH_HEALTH_FAULT_VIBRATION_ERROR = 18
BT_MESH_HEALTH_FAULT_CONFIGURATION_WARNING = 19
BT_MESH_HEALTH_FAULT_CONFIGURATION_ERROR = 20
BT_MESH_HEALTH_FAULT_ELEMENT_NOT_CALIBRATED_WARNING = 21
BT_MESH_HEALTH_FAULT_ELEMENT_NOT_CALIBRATED_ERROR = 22
BT_MESH_HEALTH_FAULT_MEMORY_WARNING = 23
BT_MESH_HEALTH_FAULT_MEMORY_ERROR = 24
BT_MESH_HEALTH_FAULT_SELF_TEST_WARNING = 25
BT_MESH_HEALTH_FAULT_SELF_TEST_ERROR = 26
BT_MESH_HEALTH_FAULT_INPUT_TOO_LOW_WARNING = 27
BT_MESH_HEALTH_FAULT_INPUT_TOO_LOW_ERROR = 28
BT_MESH_HEALTH_FAULT_INPUT_TOO_HIGH_WARNING = 29
BT_MESH_HEALTH_FAULT_INPUT_TOO_HIGH_ERROR = 30
BT_MESH_HEALTH_FAULT_INPUT_NO_CHANGE_WARNING = 31
BT_MESH_HEALTH_FAULT_INPUT_NO_CHANGE_ERROR = 32
BT_MESH_HEALTH_FAULT_ACTUATOR_BLOCKED_WARNING = 33
BT_MESH_HEALTH_FAULT_ACTUATOR_BLOCKED_ERROR = 34
BT_MESH_HEALTH_FAULT_HOUSING_OPENED_WARNING = 35
BT_MESH_HEALTH_FAULT_HOUSING_OPENED_ERROR = 36
BT_MESH_HEALTH_FAULT_TAMPER_WARNING = 37
BT_MESH_HEALTH_FAULT_TAMPER_ERROR = 38
BT_MESH_HEALTH_FAULT_DEVICE_MOVED_WARNING = 39
BT_MESH_HEALTH_FAULT_DEVICE_MOVED_ERROR = 40
BT_MESH_HEALTH_FAULT_DEVICE_DROPPED_WARNING = 41
BT_MESH_HEALTH_FAULT_DEVICE_DROPPED_ERROR = 42
BT_MESH_HEALTH_FAULT_OVERFLOW_WARNING = 43
BT_MESH_HEALTH_FAULT_OVERFLOW_ERROR = 44
BT_MESH_HEALTH_FAULT_EMPTY_WARNING = 45
BT_MESH_HEALTH_FAULT_EMPTY_ERROR = 46
BT_MESH_HEALTH_FAULT_INTERNAL_BUS_WARNING = 47
BT_MESH_HEALTH_FAULT_INTERNAL_BUS_ERROR = 48
BT_MESH_HEALTH_FAULT_MECHANISM_JAMMED_WARNING = 49
BT_MESH_HEALTH_FAULT_MECHANISM_JAMMED_ERROR = 50
   # Start of the vendor specific fault values.
# All values below this are reserved for the Bluetooth Specification.
BT_MESH_HEALTH_FAULT_VENDOR_SPECIFIC_START = 128

class bt_mesh_output_action:
    BT_MESH_NO_OUTPUT_ERPC = 0
    BT_MESH_BLINK_ERPC = 1
    BT_MESH_BEEP_ERPC = 2
    BT_MESH_VIBRATE_ERPC = 4
    BT_MESH_DISPLAY_NUMBER_ERPC = 8
    BT_MESH_DISPLAY_STRING_ERPC = 16

#Available Provisioning input authentication actions.
class bt_mesh_input_action:
    BT_MESH_NO_INPUT_ERPC = 0
    BT_MESH_PUSH_ERPC = 1
    BT_MESH_TWIST_ERPC = 2
    BT_MESH_ENTER_NUMBER_ERPC = 4
    BT_MESH_ENTER_STRING_ERPC = 8

#Available Provisioning bearers.
class bt_mesh_prov_bearer:
    BT_MESH_PROV_ADV_ERPC = 1
    BT_MESH_PROV_GATT_ERPC = 2

#Out of Band information location.
class bt_mesh_prov_oob_info:
    BT_MESH_PROV_OOB_OTHER_ERPC = 1
    BT_MESH_PROV_OOB_URI_ERPC = 2
    BT_MESH_PROV_OOB_2D_CODE_ERPC = 4
    BT_MESH_PROV_OOB_BAR_CODE_ERPC = 8
    BT_MESH_PROV_OOB_NFC_ERPC = 16
    BT_MESH_PROV_OOB_NUMBER_ERPC = 32
    BT_MESH_PROV_OOB_STRING_ERPC = 64
    BT_MESH_PROV_OOB_ON_BOX_ERPC = 128
    BT_MESH_PROV_OOB_IN_BOX_ERPC = 256
    BT_MESH_PROV_OOB_ON_PAPER_ERPC = 512
    BT_MESH_PROV_OOB_IN_MANUAL_ERPC = 1024
    BT_MESH_PROV_OOB_ON_DEV_ERPC = 2048

BT_MESH_NET_PRIMARY = 0

BT_MESH_RELAY_DISABLED = 0
BT_MESH_RELAY_ENABLED = 1
BT_MESH_RELAY_NOT_SUPPORTED = 2

BT_MESH_BEACON_DISABLED = 0
BT_MESH_BEACON_ENABLED = 1

BT_MESH_GATT_PROXY_DISABLED = 0
BT_MESH_GATT_PROXY_ENABLED = 1
BT_MESH_GATT_PROXY_NOT_SUPPORTED = 2

BT_MESH_FRIEND_DISABLED = 0
BT_MESH_FRIEND_ENABLED = 1
BT_MESH_FRIEND_NOT_SUPPORTED = 2

BT_MESH_NODE_IDENTITY_STOPPED = 0
BT_MESH_NODE_IDENTITY_RUNNING = 1
BT_MESH_NODE_IDENTITY_NOT_SUPPORTED = 2

BT_MESH_FEAT_RELAY = 1
BT_MESH_FEAT_PROXY = 2
BT_MESH_FEAT_FRIEND = 4
BT_MESH_FEAT_LOW_POWER = 8
BT_MESH_FEAT_SUPPORTED = 15

class bt_mesh_key_evt:
    BT_MESH_KEY_ADDED = 0
    BT_MESH_KEY_DELETED = 1
    BT_MESH_KEY_UPDATED = 2
    BT_MESH_KEY_SWAPPED = 3
    BT_MESH_KEY_REVOKED = 4


# Structures data types declarations
#Provisioning properties & capabilities.
class bt_mesh_prov_raw(object):
    def __init__(self, uuid=None, uri=None, oob_info=None, static_val=None, output_size=None, output_actions=None, input_size=None, input_actions=None, output_number=None, output_string=None, input=None, input_complete=None, unprovisioned_beacon=None, link_open=None, link_close=None, complete=None, node_added=None, reset=None):
        self.uuid = uuid # list<uint8>
        self.uri = uri # string
        self.oob_info = oob_info # bt_mesh_prov_oob_info
        self.static_val = static_val # list<uint8>
        self.output_size = output_size # uint8
        self.output_actions = output_actions # uint16
        self.input_size = input_size # uint8
        self.input_actions = input_actions # uint16
        self.output_number = output_number # BLEmesh_output_number
        self.output_string = output_string # BLEmesh_output_string
        self.input = input # BLEmesh_input
        self.input_complete = input_complete # BLEmesh_input_complete
        self.unprovisioned_beacon = unprovisioned_beacon # BLEmesh_unprovisioned_beacon
        self.link_open = link_open # BLEmesh_link_open
        self.link_close = link_close # BLEmesh_link_close
        self.complete = complete # BLEmesh_complete
        self.node_added = node_added # BLEmesh_node_added
        self.reset = reset # BLEmesh_reset

    @property
    def static_val_len(self):
        return len(self.static_val)

    @property
    def uuid_len(self):
        return len(self.uuid)

    def _read(self, codec):
        _n0 = codec.start_read_list()
        self.uuid = []
        for _i0 in range(_n0):
            _v0 = codec.read_uint8()
            self.uuid.append(_v0)

        self.uri = codec.read_string()
        self.oob_info = codec.read_uint32()
        if not codec.read_null_flag():
            _n0 = codec.start_read_list()
            self.static_val = []
            for _i0 in range(_n0):
                _v0 = codec.read_uint8()
                self.static_val.append(_v0)

        else:
            self.static_val = None
        self.output_size = codec.read_uint8()
        self.output_actions = codec.read_uint16()
        self.input_size = codec.read_uint8()
        self.input_actions = codec.read_uint16()
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.output_number = output_number_cb

        else:
            self.output_number = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.output_string = output_string_cb

        else:
            self.output_string = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.input = input_cb

        else:
            self.input = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.input_complete = input_complete_cb

        else:
            self.input_complete = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.unprovisioned_beacon = unprovisioned_beacon_cb

        else:
            self.unprovisioned_beacon = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.link_open = link_open_cb

        else:
            self.link_open = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.link_close = link_close_cb

        else:
            self.link_close = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.complete = complete_cb

        else:
            self.complete = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.node_added = node_added_cb

        else:
            self.node_added = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.reset = reset_prov_cb

        else:
            self.reset = None
        return self

    def _write(self, codec):
        if self.uuid is None:
            raise ValueError("uuid is None")
        codec.start_write_list(len(self.uuid))
        for _i0 in self.uuid:
            codec.write_uint8(_i0)

        if self.uri is None:
            raise ValueError("uri is None")
        codec.write_string(self.uri)
        if self.oob_info is None:
            raise ValueError("oob_info is None")
        codec.write_uint32(self.oob_info)
        if self.static_val is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            codec.start_write_list(len(self.static_val))
            for _i0 in self.static_val:
                codec.write_uint8(_i0)

        if self.output_size is None:
            raise ValueError("output_size is None")
        codec.write_uint8(self.output_size)
        if self.output_actions is None:
            raise ValueError("output_actions is None")
        codec.write_uint16(self.output_actions)
        if self.input_size is None:
            raise ValueError("input_size is None")
        codec.write_uint8(self.input_size)
        if self.input_actions is None:
            raise ValueError("input_actions is None")
        codec.write_uint16(self.input_actions)
        if self.output_number is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.output_string is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.input is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.input_complete is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.unprovisioned_beacon is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.link_open is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.link_close is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.complete is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.node_added is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.reset is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.


    def __str__(self):
        return "<%s@%x uuid=%s uri=%s oob_info=%s static_val=%s output_size=%s output_actions=%s input_size=%s input_actions=%s output_number=%s output_string=%s input=%s input_complete=%s unprovisioned_beacon=%s link_open=%s link_close=%s complete=%s node_added=%s reset=%s>" % (self.__class__.__name__, id(self), self.uuid, self.uri, self.oob_info, self.static_val, self.output_size, self.output_actions, self.input_size, self.input_actions, self.output_number, self.output_string, self.input, self.input_complete, self.unprovisioned_beacon, self.link_open, self.link_close, self.complete, self.node_added, self.reset)

    def __repr__(self):
        return self.__str__()

#Node Composition
class bt_mesh_comp_raw(object):
    def __init__(self, cid=None, pid=None, vid=None, elem_count=None, elem_placeholder=None):
        self.cid = cid # uint16
        self.pid = pid # uint16
        self.vid = vid # uint16
        self.elem_count = elem_count # int32
        self.elem_placeholder = elem_placeholder # uint32

    def _read(self, codec):
        self.cid = codec.read_uint16()
        self.pid = codec.read_uint16()
        self.vid = codec.read_uint16()
        self.elem_count = codec.read_int32()
        self.elem_placeholder = codec.read_uint32()
        return self

    def _write(self, codec):
        if self.cid is None:
            raise ValueError("cid is None")
        codec.write_uint16(self.cid)
        if self.pid is None:
            raise ValueError("pid is None")
        codec.write_uint16(self.pid)
        if self.vid is None:
            raise ValueError("vid is None")
        codec.write_uint16(self.vid)
        if self.elem_count is None:
            raise ValueError("elem_count is None")
        codec.write_int32(self.elem_count)
        if self.elem_placeholder is None:
            raise ValueError("elem_placeholder is None")
        codec.write_uint32(self.elem_placeholder)

    def __str__(self):
        return "<%s@%x cid=%s pid=%s vid=%s elem_count=%s elem_placeholder=%s>" % (self.__class__.__name__, id(self), self.cid, self.pid, self.vid, self.elem_count, self.elem_placeholder)

    def __repr__(self):
        return self.__str__()

#Abstraction that describes a Mesh Element
class bt_mesh_elem_raw(object):
    def __init__(self, addr=None, loc=None, model_count=None, vnd_model_count=None, models_placeholder=None, vnd_models_placeholder=None):
        self.addr = addr # uint16
        self.loc = loc # uint16
        self.model_count = model_count # uint8
        self.vnd_model_count = vnd_model_count # uint8
        self.models_placeholder = models_placeholder # uint32
        self.vnd_models_placeholder = vnd_models_placeholder # uint32

    def _read(self, codec):
        self.addr = codec.read_uint16()
        self.loc = codec.read_uint16()
        self.model_count = codec.read_uint8()
        self.vnd_model_count = codec.read_uint8()
        self.models_placeholder = codec.read_uint32()
        self.vnd_models_placeholder = codec.read_uint32()
        return self

    def _write(self, codec):
        if self.addr is None:
            raise ValueError("addr is None")
        codec.write_uint16(self.addr)
        if self.loc is None:
            raise ValueError("loc is None")
        codec.write_uint16(self.loc)
        if self.model_count is None:
            raise ValueError("model_count is None")
        codec.write_uint8(self.model_count)
        if self.vnd_model_count is None:
            raise ValueError("vnd_model_count is None")
        codec.write_uint8(self.vnd_model_count)
        if self.models_placeholder is None:
            raise ValueError("models_placeholder is None")
        codec.write_uint32(self.models_placeholder)
        if self.vnd_models_placeholder is None:
            raise ValueError("vnd_models_placeholder is None")
        codec.write_uint32(self.vnd_models_placeholder)

    def __str__(self):
        return "<%s@%x addr=%s loc=%s model_count=%s vnd_model_count=%s models_placeholder=%s vnd_models_placeholder=%s>" % (self.__class__.__name__, id(self), self.addr, self.loc, self.model_count, self.vnd_model_count, self.models_placeholder, self.vnd_models_placeholder)

    def __repr__(self):
        return self.__str__()

class net_buf_simple_raw(object):
    def __init__(self, data=None, size=None, __buf=None):
        self.data = data # list<uint8>
        self.size = size # uint16
        self.__buf = __buf # uint8

    @property
    def len(self):
        return len(self.data)

    def _read(self, codec):
        _n0 = codec.start_read_list()
        self.data = []
        for _i0 in range(_n0):
            _v0 = codec.read_uint8()
            self.data.append(_v0)

        self.size = codec.read_uint16()
        self.__buf = codec.read_uint8()
        return self

    def _write(self, codec):
        if self.data is None:
            raise ValueError("data is None")
        codec.start_write_list(len(self.data))
        for _i0 in self.data:
            codec.write_uint8(_i0)

        if self.size is None:
            raise ValueError("size is None")
        codec.write_uint16(self.size)
        if self.__buf is None:
            raise ValueError("__buf is None")
        codec.write_uint8(self.__buf)

    def __str__(self):
        return "<%s@%x data=%s size=%s __buf=%s>" % (self.__class__.__name__, id(self), self.data, self.size, self.__buf)

    def __repr__(self):
        return self.__str__()

class bt_mesh_model_pub_raw(object):
    def __init__(self, addr=None, key=None, ttl=None, retransmit=None, period=None, period_div=None, period_start=None, msg=None, update=None):
        self.addr = addr # uint16
        self.key = key # uint16
        self.ttl = ttl # uint8
        self.retransmit = retransmit # uint8
        self.period = period # uint8
        self.period_div = period_div # uint8
        self.period_start = period_start # uint32
        self.msg = msg # net_buf_simple_raw
        self.update = update # BLEmesh_update

    def _read(self, codec):
        self.addr = codec.read_uint16()
        self.key = codec.read_uint16()
        self.ttl = codec.read_uint8()
        self.retransmit = codec.read_uint8()
        self.period = codec.read_uint8()
        self.period_div = codec.read_uint8()
        self.period_start = codec.read_uint32()
        self.msg = net_buf_simple_raw()._read(codec)
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.update = update_cb

        else:
            self.update = None
        return self

    def _write(self, codec):
        if self.addr is None:
            raise ValueError("addr is None")
        codec.write_uint16(self.addr)
        if self.key is None:
            raise ValueError("key is None")
        codec.write_uint16(self.key)
        if self.ttl is None:
            raise ValueError("ttl is None")
        codec.write_uint8(self.ttl)
        if self.retransmit is None:
            raise ValueError("retransmit is None")
        codec.write_uint8(self.retransmit)
        if self.period is None:
            raise ValueError("period is None")
        codec.write_uint8(self.period)
        if self.period_div is None:
            raise ValueError("period_div is None")
        codec.write_uint8(self.period_div)
        if self.period_start is None:
            raise ValueError("period_start is None")
        codec.write_uint32(self.period_start)
        if self.msg is None:
            raise ValueError("msg is None")
        self.msg._write(codec)
        if self.update is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.


    def __str__(self):
        return "<%s@%x addr=%s key=%s ttl=%s retransmit=%s period=%s period_div=%s period_start=%s msg=%s update=%s>" % (self.__class__.__name__, id(self), self.addr, self.key, self.ttl, self.retransmit, self.period, self.period_div, self.period_start, self.msg, self.update)

    def __repr__(self):
        return self.__str__()

class bt_mesh_model_raw(object):
    class model_union(object):
        # case SIG_MODEL
        id = None # uint16
        # case VND_MODEL
        company = None # uint16
        vnd_id = None # uint16

    def __init__(self, model_type=None, model=None, pub=None, cb=None, user_data=None):
        self.model_type = model_type # int32
        self.model = model # model_union
        self.pub = pub # bt_mesh_model_pub_raw
        self.cb = cb # bt_mesh_model_cb_raw
        self.user_data = user_data # string

    def _read(self, codec):
        self.model_type = codec.start_read_union()
        self.model = self.model_union()
        if self.model_type == 0:
            self.model.id = codec.read_uint16()
        elif self.model_type == 1:
            self.model.company = codec.read_uint16()
            self.model.vnd_id = codec.read_uint16()
        else:
            raise ValueError("invalid union discriminator value %s" % repr(self.model_type))

        if not codec.read_null_flag():
            self.pub = bt_mesh_model_pub_raw()._read(codec)
        else:
            self.pub = None
        if not codec.read_null_flag():
            self.cb = bt_mesh_model_cb_raw()._read(codec)
        else:
            self.cb = None
        if not codec.read_null_flag():
            self.user_data = codec.read_string()
        else:
            self.user_data = None
        return self

    def _write(self, codec):
        if self.model is None:
            raise ValueError("model is None")
        codec.start_write_union(self.model_type)
        if self.model_type == 0:
            if self.model.id is None:
                raise ValueError("self.model.id is None")
            codec.write_uint16(self.model.id)
        elif self.model_type == 1:
            if self.model.company is None:
                raise ValueError("self.model.company is None")
            codec.write_uint16(self.model.company)
            if self.model.vnd_id is None:
                raise ValueError("self.model.vnd_id is None")
            codec.write_uint16(self.model.vnd_id)
        else:
            raise ValueError("invalid union discriminator value %s" % repr(self.model_type))

        if self.pub is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            self.pub._write(codec)
        if self.cb is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            self.cb._write(codec)
        if self.user_data is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            codec.write_string(self.user_data)

    def __str__(self):
        return "<%s@%x model_type=%s model=%s pub=%s cb=%s user_data=%s>" % (self.__class__.__name__, id(self), self.model_type, self.model, self.pub, self.cb, self.user_data)

    def __repr__(self):
        return self.__str__()

#Model callback functions.
class bt_mesh_model_cb_raw(object):
    def __init__(self, settings_set=None, start=None, init=None, reset=None):
        self.settings_set = settings_set # BLEmesh_settings_set_cb
        self.start = start # BLEmesh_start_cb
        self.init = init # BLEmesh_init_cb
        self.reset = reset # BLEmesh_reset_cb

    def _read(self, codec):
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.settings_set = settings_set_cb

        else:
            self.settings_set = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.start = start_cb

        else:
            self.start = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.init = init_cb

        else:
            self.init = None
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.reset = reset_cb

        else:
            self.reset = None
        return self

    def _write(self, codec):
        if self.settings_set is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.start is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.init is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.reset is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.


    def __str__(self):
        return "<%s@%x settings_set=%s start=%s init=%s reset=%s>" % (self.__class__.__name__, id(self), self.settings_set, self.start, self.init, self.reset)

    def __repr__(self):
        return self.__str__()

#Model opcode handler.
class bt_mesh_model_op_raw(object):
    def __init__(self, opcode=None, min_len=None, func=None):
        self.opcode = opcode # uint32
        self.min_len = min_len # int32
        self.func = func # BLEmesh_func

    def _read(self, codec):
        self.opcode = codec.read_uint32()
        self.min_len = codec.read_int32()
        if not codec.read_null_flag():
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.
            self.func = func_cb

        else:
            self.func = None
        return self

    def _write(self, codec):
        if self.opcode is None:
            raise ValueError("opcode is None")
        codec.write_uint32(self.opcode)
        if self.min_len is None:
            raise ValueError("min_len is None")
        codec.write_int32(self.min_len)
        if self.func is None:
            codec.write_null_flag(True)
        else:
            codec.write_null_flag(False)
            # When are defined less than 2 callback functions, eRPC don't need serialize any code.


    def __str__(self):
        return "<%s@%x opcode=%s min_len=%s func=%s>" % (self.__class__.__name__, id(self), self.opcode, self.min_len, self.func)

    def __repr__(self):
        return self.__str__()

class bt_mesh_health_srv_raw(object):
    def __init__(self, model_placeholder=None, cb=None, k_delayed_work_placeholder=None):
        self.model_placeholder = model_placeholder # uint32
        self.cb = cb # bt_mesh_health_srv_cb_raw
        self.k_delayed_work_placeholder = k_delayed_work_placeholder # uint32

    def _read(self, codec):
        self.model_placeholder = codec.read_uint32()
        self.cb = bt_mesh_health_srv_cb_raw()._read(codec)
        self.k_delayed_work_placeholder = codec.read_uint32()
        return self

    def _write(self, codec):
        if self.model_placeholder is None:
            raise ValueError("model_placeholder is None")
        codec.write_uint32(self.model_placeholder)
        if self.cb is None:
            raise ValueError("cb is None")
        self.cb._write(codec)
        if self.k_delayed_work_placeholder is None:
            raise ValueError("k_delayed_work_placeholder is None")
        codec.write_uint32(self.k_delayed_work_placeholder)

    def __str__(self):
        return "<%s@%x model_placeholder=%s cb=%s k_delayed_work_placeholder=%s>" % (self.__class__.__name__, id(self), self.model_placeholder, self.cb, self.k_delayed_work_placeholder)

    def __repr__(self):
        return self.__str__()

#Callback function for the Health Server model
class bt_mesh_health_srv_cb_raw(object):
    def __init__(self, fault_get_cur=None, fault_get_reg=None, fault_clear=None, fault_test=None, attn_on=None, attn_off=None):
        self.fault_get_cur = fault_get_cur # BLEmesh_fault_get_cur
        self.fault_get_reg = fault_get_reg # BLEmesh_fault_get_reg
        self.fault_clear = fault_clear # BLEmesh_fault_clear
        self.fault_test = fault_test # BLEmesh_fault_test
        self.attn_on = attn_on # BLEmesh_attn_on
        self.attn_off = attn_off # BLEmesh_attn_off

    def _read(self, codec):
        # When are defined less than 2 callback functions, eRPC don't need serialize any code.
        self.fault_get_cur = fault_get_cur_cb

        # When are defined less than 2 callback functions, eRPC don't need serialize any code.
        self.fault_get_reg = fault_get_reg_cb

        # When are defined less than 2 callback functions, eRPC don't need serialize any code.
        self.fault_clear = fault_clear_cb

        # When are defined less than 2 callback functions, eRPC don't need serialize any code.
        self.fault_test = fault_test_cb

        # When are defined less than 2 callback functions, eRPC don't need serialize any code.
        self.attn_on = attn_on_cb

        # When are defined less than 2 callback functions, eRPC don't need serialize any code.
        self.attn_off = attn_off_cb

        return self

    def _write(self, codec):
        if self.fault_get_cur is None:
            raise ValueError("fault_get_cur is None")
        # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.fault_get_reg is None:
            raise ValueError("fault_get_reg is None")
        # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.fault_clear is None:
            raise ValueError("fault_clear is None")
        # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.fault_test is None:
            raise ValueError("fault_test is None")
        # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.attn_on is None:
            raise ValueError("attn_on is None")
        # When are defined less than 2 callback functions, eRPC don't need serialize any code.

        if self.attn_off is None:
            raise ValueError("attn_off is None")
        # When are defined less than 2 callback functions, eRPC don't need serialize any code.


    def __str__(self):
        return "<%s@%x fault_get_cur=%s fault_get_reg=%s fault_clear=%s fault_test=%s attn_on=%s attn_off=%s>" % (self.__class__.__name__, id(self), self.fault_get_cur, self.fault_get_reg, self.fault_clear, self.fault_test, self.attn_on, self.attn_off)

    def __repr__(self):
        return self.__str__()

#Model publication configuration parameters.
class bt_mesh_cfg_mod_pub_raw(object):
    def __init__(self, addr=None, app_idx=None, cred_flag=None, ttl=None, period=None, transmit=None):
        self.addr = addr # uint16
        self.app_idx = app_idx # uint16
        self.cred_flag = cred_flag # bool
        self.ttl = ttl # uint8
        self.period = period # uint8
        self.transmit = transmit # uint8

    def _read(self, codec):
        self.addr = codec.read_uint16()
        self.app_idx = codec.read_uint16()
        self.cred_flag = codec.read_bool()
        self.ttl = codec.read_uint8()
        self.period = codec.read_uint8()
        self.transmit = codec.read_uint8()
        return self

    def _write(self, codec):
        if self.addr is None:
            raise ValueError("addr is None")
        codec.write_uint16(self.addr)
        if self.app_idx is None:
            raise ValueError("app_idx is None")
        codec.write_uint16(self.app_idx)
        if self.cred_flag is None:
            raise ValueError("cred_flag is None")
        codec.write_bool(self.cred_flag)
        if self.ttl is None:
            raise ValueError("ttl is None")
        codec.write_uint8(self.ttl)
        if self.period is None:
            raise ValueError("period is None")
        codec.write_uint8(self.period)
        if self.transmit is None:
            raise ValueError("transmit is None")
        codec.write_uint8(self.transmit)

    def __str__(self):
        return "<%s@%x addr=%s app_idx=%s cred_flag=%s ttl=%s period=%s transmit=%s>" % (self.__class__.__name__, id(self), self.addr, self.app_idx, self.cred_flag, self.ttl, self.period, self.transmit)

    def __repr__(self):
        return self.__str__()

#Message sending context.
class bt_mesh_msg_ctx_raw(object):
    def __init__(self, net_idx=None, app_idx=None, addr=None, recv_dst=None, recv_rssi=None, recv_ttl=None, send_rel=None, send_ttl=None):
        self.net_idx = net_idx # uint16
        self.app_idx = app_idx # uint16
        self.addr = addr # uint16
        self.recv_dst = recv_dst # uint16
        self.recv_rssi = recv_rssi # int8
        self.recv_ttl = recv_ttl # uint8
        self.send_rel = send_rel # bool
        self.send_ttl = send_ttl # uint8

    def _read(self, codec):
        self.net_idx = codec.read_uint16()
        self.app_idx = codec.read_uint16()
        self.addr = codec.read_uint16()
        self.recv_dst = codec.read_uint16()
        self.recv_rssi = codec.read_int8()
        self.recv_ttl = codec.read_uint8()
        self.send_rel = codec.read_bool()
        self.send_ttl = codec.read_uint8()
        return self

    def _write(self, codec):
        if self.net_idx is None:
            raise ValueError("net_idx is None")
        codec.write_uint16(self.net_idx)
        if self.app_idx is None:
            raise ValueError("app_idx is None")
        codec.write_uint16(self.app_idx)
        if self.addr is None:
            raise ValueError("addr is None")
        codec.write_uint16(self.addr)
        if self.recv_dst is None:
            raise ValueError("recv_dst is None")
        codec.write_uint16(self.recv_dst)
        if self.recv_rssi is None:
            raise ValueError("recv_rssi is None")
        codec.write_int8(self.recv_rssi)
        if self.recv_ttl is None:
            raise ValueError("recv_ttl is None")
        codec.write_uint8(self.recv_ttl)
        if self.send_rel is None:
            raise ValueError("send_rel is None")
        codec.write_bool(self.send_rel)
        if self.send_ttl is None:
            raise ValueError("send_ttl is None")
        codec.write_uint8(self.send_ttl)

    def __str__(self):
        return "<%s@%x net_idx=%s app_idx=%s addr=%s recv_dst=%s recv_rssi=%s recv_ttl=%s send_rel=%s send_ttl=%s>" % (self.__class__.__name__, id(self), self.net_idx, self.app_idx, self.addr, self.recv_dst, self.recv_rssi, self.recv_ttl, self.send_rel, self.send_ttl)

    def __repr__(self):
        return self.__str__()


# Unions data types declarations
class model_union(object):
    # case SIG_MODEL
    id = None # uint16
    # case VND_MODEL
    company = None # uint16
    vnd_id = None # uint16

    def _read(self, codec):
        self.model_type = codec.start_read_union()
        self = self_union()
        if self.model_type == 0:
            self.id = codec.read_uint16()
        elif self.model_type == 1:
            self.company = codec.read_uint16()
            self.vnd_id = codec.read_uint16()
        else:
            raise ValueError("invalid union discriminator value %s" % repr(self.model_type))

        return self, discriminator

    def _write(self, codec, discriminator):
        codec.start_write_union(self.model_type)
        if self.model_type == 0:
            if self.id is None:
                raise ValueError("self.id is None")
            codec.write_uint16(self.id)
        elif self.model_type == 1:
            if self.company is None:
                raise ValueError("self.company is None")
            codec.write_uint16(self.company)
            if self.vnd_id is None:
                raise ValueError("self.vnd_id is None")
            codec.write_uint16(self.vnd_id)
        else:
            raise ValueError("invalid union discriminator value %s" % repr(self.model_type))


    def __repr__(self):
        return self.__str__()


