/*
 * Copyright (c) 2018, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// @cliArgs --board /ti/boards/CC1352R1_LAUNCHXL --rtos tirtos7

/*
 *  multi_sensor.syscfg
 */

/* ======== BAS Sensors BoosterPack ======== */
var BOOSTXL_BASSENSORS = scripting.addHardware("/ti/boards/boosterpacks/BOOSTXL-BASSENSORS");

/* ======== Power ======== */
var Power = scripting.addModule("/ti/drivers/Power");

/* ======== Board ======== */
var Board = scripting.addModule("/ti/drivers/Board");

/* ======== DriverLib ======== */
var DriverLib = scripting.addModule("/ti/devices/DriverLib");

/* ======== Device ======== */
var CCFG = scripting.addModule("/ti/devices/CCFG");
// Temporarily disable ti_devices_config.c generation
CCFG.enableCodeGeneration = false;

/* ======== AESCCM ======== */
var AESCCM = scripting.addModule("/ti/drivers/AESCCM");
var AESCCM1 = AESCCM.addInstance();
// Name
AESCCM1.$name = "CONFIG_AESCCM0";

/* ======== AESECB ======== */
var AESECB = scripting.addModule("/ti/drivers/AESECB");
var AESECB1 = AESECB.addInstance();
// Name
AESECB1.$name = "CONFIG_AESECB0";

/* ======== ECDH ======== */
var ECDH = scripting.addModule("/ti/drivers/ECDH");
var ECDH1 = ECDH.addInstance();
// Name
ECDH1.$name = "CONFIG_ECDH0";

/* ======== AESCTRDRBG ======== */
var AESCTRDRBG = scripting.addModule("/ti/drivers/AESCTRDRBG");
var aesctrdrbg = AESCTRDRBG.addInstance();



/* ======== RF ======== */
var RF = scripting.addModule("/ti/drivers/RF");

/* if an antenna component exists, assign it to the rf instance */
if (system.deviceData.board && system.deviceData.board.components.RF) {
    RF.$hardware = system.deviceData.board.components.RF;
}

/* ======== TRNG ======== */
var TRNG = scripting.addModule("/ti/drivers/TRNG");
var TRNG1 = TRNG.addInstance();
// Name - The C/C++ identifier used in applications as the index parameter passed to TRNG runtime APIs
TRNG1.$name = "CONFIG_TRNG_0";

/* ======== ADC ======== */
var ADC = scripting.addModule("/ti/drivers/ADC");
var ADC1 = ADC.addInstance();
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
ADC1.$hardware = BOOSTXL_BASSENSORS.components.DRV5055.subComponents.OUTPUT;
// Name - The C/C++ identifier used in applications as the index parameter passed to ADC runtime APIs
ADC1.$name = "CONFIG_ADC0";
// Name
ADC1.adcPinInstance.$name = "Board_PIN2";
// Name
ADC1.adc.$name = "MyADC1";

/* ======== DMA ======== */
var DMA = scripting.addModule("/ti/drivers/DMA");

/* ======== GPIO ======== */
var GPIO = scripting.addModule("/ti/drivers/GPIO");
var GPIO1 = GPIO.addInstance();
var GPIO2 = GPIO.addInstance();
var GPIO3 = GPIO.addInstance();
var GPIO4 = GPIO.addInstance();
var GPIO8 = GPIO.addInstance();
// Pull - Specifies the internal pull-up or pull-down resistor configuration of this GPIO pin.
GPIO1.pull = "Pull Up";
// Name - The C/C++ identifier used in applications as the index parameter passed to GPIO runtime APIs
GPIO1.$name = "CONFIG_GPIO_OPT_INT";
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
GPIO1.$hardware = BOOSTXL_BASSENSORS.components.OPT3001.subComponents.ALERT;
// Name
// Output Strength
GPIO2.initialOutputState = "High";
// Name - The C/C++ identifier used in applications as the index parameter passed to GPIO runtime APIs
GPIO2.$name = "CONFIG_GPIO_OPT_PWR";
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
GPIO2.$hardware = BOOSTXL_BASSENSORS.components.OPT3001.subComponents.POWER;
// Name
// Name - The C/C++ identifier used in applications as the index parameter passed to GPIO runtime APIs
GPIO3.$name = "CONFIG_GPIO_HDC_PWR";
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
GPIO3.$hardware = BOOSTXL_BASSENSORS.components.HDC2010.subComponents.POWER;
// Name
// Name - The C/C++ identifier used in applications as the index parameter passed to GPIO runtime APIs
GPIO4.$name = "CONFIG_GPIO_HDC_INT";
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
GPIO4.$hardware = BOOSTXL_BASSENSORS.components.HDC2010.subComponents.ALERT;
// Name
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
GPIO8.$hardware = BOOSTXL_BASSENSORS.components.DRV5055.subComponents.POWER;
// Name - The C/C++ identifier used in applications as the index parameter passed to GPIO runtime APIs
GPIO8.$name = "CONFIG_DRV_PWR";
// Name

/* ======== Display ======== */
var Display = scripting.addModule("/ti/display/Display");
var Display1 = Display.addInstance();
// Name - The C/C++ identifier used in applications as the index parameter passed to Display runtime APIs
Display1.$name = "Board_Display0";
// Enable ANSI - Enables or disables ANSI cursor support.
Display1.enableANSI = true;
// UART Buffer Size - UART display buffer size in bytes
Display1.uartBufferSize = 128;
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
Display1.$hardware = system.deviceData.board.components.XDS110UART;
// Name - The C/C++ identifier used in applications as the index parameter passed to UART runtime APIs
Display1.uart.$name = "CONFIG_UART_0";
// Name
Display1.uart.txPinInstance.$name = "CONFIG_GPIO_12";
// Name
Display1.uart.rxPinInstance.$name = "CONFIG_GPIO_13";
// Name
Display1.uart.uart.$name = "MyUART1";
// Use Peripheral
Display1.uart.uart.$assign = "UART0";

/* ======== NVS ======== */
var NVS = scripting.addModule("/ti/drivers/NVS");
var NVS1 = NVS.addInstance();
var NVS2 = NVS.addInstance();
// Name - The C/C++ identifier used in applications as the index parameter passed to NVS runtime APIs
NVS1.$name = "CONFIG_NVSINTERNAL";
// Name
NVS1.internalFlash.$name = "ti_drivers_nvs_NVSCC26XX0";
// Region Base - Base address of the region. Must be aligned an integer multiple of sector size boundary.
NVS1.internalFlash.regionBase = 0x48000;
// Region Size - Size of the region in bytes. Must be a non-zero multiple of the Sector Size
NVS1.internalFlash.regionSize = 0x4000;
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
NVS2.$hardware = system.deviceData.board.components.MX25R8035F;
// Name - The C/C++ identifier used in applications as the index parameter passed to NVS runtime APIs
NVS2.$name = "CONFIG_NVSEXTERNAL";
// Name
NVS2.externalFlash.$name = "ti_drivers_nvs_NVSSPI25X0";
// Region Size - Size of the region in bytes. Must be a non-zero multiple of the Sector Size
NVS2.externalFlash.regionSize = 0x100000;
// Verify Buffer Size - Size of the write verification buffer in bytes.
NVS2.externalFlash.verifyBufferSize = 64;
var NVSSPI25XDevice1 = NVS2.externalFlash.spiFlashDevice; // Create reference
// Name
NVSSPI25XDevice1.$name = "CONFIG_NVS_SPI_0";
// Name - The C/C++ identifier used in applications as the index parameter passed to GPIO runtime APIs
// Name

/* ======== SPI ======== */
var SPI1 = NVSSPI25XDevice1.sharedSpiInstance; // Create reference
// Name - The C/C++ identifier used in applications as the index parameter passed to SPI runtime APIs
SPI1.$name = "CONFIG_SPI_0";
// Name
SPI1.sclkPinInstance.$name = "CONFIG_GPIO_1";
// Name
SPI1.misoPinInstance.$name = "CONFIG_GPIO_2";
// Name
SPI1.mosiPinInstance.$name = "CONFIG_GPIO_3";
// Name
SPI1.spi.$name = "MySSI1";

/* ======== I2C ======== */
var I2C = scripting.addModule("/ti/drivers/I2C");
var I2C1 = I2C.addInstance();
// Name - The C/C++ identifier used in applications as the index parameter passed to I2C runtime APIs
I2C1.$name = "I2C_SENSORS";
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
I2C1.$hardware = BOOSTXL_BASSENSORS.components.BOOSTXL_BASSENSORS_I2C;
// Name
I2C1.i2c.$name = "MyI2C1";


/* ======== PWM ======== */
var PWM = scripting.addModule("/ti/drivers/PWM");

/* ======== Button ======== */
var Button = scripting.addModule("/ti/drivers/apps/Button");
var Button1 = Button.addInstance();
var Button2 = Button.addInstance();
// Name - The C/C++ identifier used in applications as the index parameter passed to Button runtime APIs
Button1.$name = "CONFIG_BUTTON_0";
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
Button1.$hardware = system.deviceData.board.components["BTN-1"];
// Pull - Specifies the internal pull-up or pull-down resistor configuration of this GPIO pin.
Button1.gpioPin.pull = "Pull Up";
// Name - The C/C++ identifier used in applications as the index parameter passed to GPIO runtime APIs
Button1.gpioPin.$name = "GPIO_BTN1";
// Name
// Name - The C/C++ identifier used in applications as the index parameter passed to Button runtime APIs
Button2.$name = "CONFIG_BUTTON_1";
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
Button2.$hardware = system.deviceData.board.components["BTN-2"];
// Pull - Specifies the internal pull-up or pull-down resistor configuration of this GPIO pin.
Button2.gpioPin.pull = "Pull Up";
// Name - The C/C++ identifier used in applications as the index parameter passed to GPIO runtime APIs
Button2.gpioPin.$name = "GPIO_BTN2";
// Name

/* ======== LED ======== */
var LED = scripting.addModule("/ti/drivers/apps/LED");
var LED1 = LED.addInstance();
var LED2 = LED.addInstance();
var LED3 = LED.addInstance();
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
LED1.$hardware = BOOSTXL_BASSENSORS.components.LED_G;
// Dimmable - Determines whether control of brightness is required
LED1.dimmable = true;
// Name - The C/C++ identifier used in applications as the index parameter passed to LED runtime APIs
LED1.$name = "GREEN_LED";
// Name - The C/C++ identifier used in applications as the index parameter passed to GPTimerCC26XX runtime APIs
LED1.pwmPin.timerObject.$name = "CONFIG_GPTIMER_0";
// Name
LED1.pwmPin.timerObject.timer.$name = "MyGPTM1";
// Name
LED1.pwmPin.timerObject.pwmPinInstance.$name = "CONFIG_GPIO_6";
// Use Hardware - Select the hardware to use, or 'None' to use available header pins
LED2.$hardware = BOOSTXL_BASSENSORS.components.LED_R;
// Dimmable - Determines whether control of brightness is required
LED2.dimmable = true;
// Name - The C/C++ identifier used in applications as the index parameter passed to LED runtime APIs
LED2.$name = "RED_LED";
// Name - The C/C++ identifier used in applications as the index parameter passed to GPTimerCC26XX runtime APIs
LED2.pwmPin.timerObject.$name = "CONFIG_GPTIMER_1";
// Name
LED2.pwmPin.timerObject.timer.$name = "MyGPTM1";
// Name
LED2.pwmPin.timerObject.pwmPinInstance.$name = "CONFIG_GPIO_7";
// Dimmable - Determines whether control of brightness is required
LED3.dimmable = true;
// Name - The C/C++ identifier used in applications as the index parameter passed to LED runtime APIs
LED3.$name = "BLUE_LED";
// Name - The C/C++ identifier used in applications as the index parameter passed to GPTimerCC26XX runtime APIs
LED3.pwmPin.timerObject.$name = "CONFIG_GPTIMER_3";
// Name
LED3.pwmPin.timerObject.timer.$name = "MyGPTM1";
// Name
LED3.pwmPin.timerObject.pwmPinInstance.$name = "CONFIG_GPIO_11";

/* ======== RF Design ======== */
var rfDesign = scripting.addModule("ti/devices/radioconfig/rfdesign");
const rfDesignSettings = system.getScript("/ti/common/lprf_rf_design_settings.js").rfDesignSettings;
for(var setting in rfDesignSettings)
{
    rfDesign[setting] = rfDesignSettings[setting];
}

const radioSettings = system.getScript("/ti/ble5stack/ble_common.js").getRadioScript(rfDesign.rfDesign,system.deviceData.deviceId);
const bleRfDesignSettings = radioSettings.rfDesignParams;
for(var setting in bleRfDesignSettings)
{
    rfDesign[setting] = bleRfDesignSettings[setting];
}

/* ======== Radio ======== */
var custom = scripting.addModule("/ti/devices/radioconfig/custom");
var bleRadioSetModule;

if(rfDesignSettings.rfDesign == "LAUNCHXL-CC1352P-4")
{
    custom.ble = ["bt5le2mp10"];
    bleRadioSetModule = custom.radioConfigbt5le2mp10;
}
else
{
    custom.ble = ["bt5le2m"];
    bleRadioSetModule = custom.radioConfigbt5le2m;
}

bleRadioSetModule.paramVisibility = false;
const bleRadioSettings = radioSettings.radioConfigParams;
for(var setting in bleRadioSettings)
{
    bleRadioSetModule.codeExportConfig[setting] = bleRadioSettings[setting];
}

if(rfDesignSettings.rfDesign == "LAUNCHXL-CC1352P-2" || rfDesignSettings.rfDesign == "LAUNCHXL-CC1352P-4")
{
    bleRadioSetModule.highPA = true;
	if(rfDesignSettings.rfDesign == "LAUNCHXL-CC1352P-4")
	{
        bleRadioSetModule.txPowerHi = "10";
	}
}

if (system.getRTOS() === "tirtos7")
{
    /* ******* Add SYS/BIOS 7.x to the configuration ********* */
    /* ================ Kernel (SYS/BIOS) configuration ================ */
    const BIOS  = scripting.addModule("/ti/sysbios/BIOS");
    /*
    * Enable asserts in the BIOS library.
    *
    * Pick one:
    *  - true (default)
    *      Enables asserts for debugging purposes.
    *  - false
    *      Disables asserts for a reduced code footprint and better performance.
    */
    //BIOS.assertsEnabled = true;
    BIOS.assertsEnabled = false;

    /*
    * Runtime instance creation enable flag.
    *
    * Pick one:
    *   - true (default)
    *      Allows Mod_create() and Mod_delete() to be called at runtime which
    *      requires a default heap for dynamic memory allocation.
    *   - false
    *      Reduces code footprint by disallowing Mod_create() and Mod_delete() to
    *      be called at runtime. Object instances are constructed via
    *      Mod_construct() and destructed via Mod_destruct().
    */
    BIOS.runtimeCreatesEnabled = true;
    //BIOS.runtimeCreatesEnabled = false;

    /* ================ Memory configuration ================ */
    /*
    * Use HeapMem primary heap instance to use linker-defined memory region
    * Add HeapTrack on top to find over-writes, invalid frees, and
    * aid in finding the correct sizing of the heap and memory leaks.
    */
    //BIOS.heapBaseAddr = "__primary_heap_start__";
    //BIOS.heapEndAddr = "__primary_heap_end__";
    // BIOS.heapTrackEnabled = true;
    BIOS.heapTrackEnabled = false;
    BIOS.rtsGateType = "BIOS_GateMutexPri";
    BIOS.heapSize = 0x00000000;
    BIOS.heapType = "HeapCallback";

    const HeapMem       = scripting.addModule("/ti/sysbios/heaps/HeapMem", {}, false);

    HeapMem.modGateType = "GateMutexPri";

    const HeapCallback = scripting.addModule("/ti/sysbios/heaps/HeapCallback");

    HeapCallback.initFxn = 'osalHeapInitFxn'; // Call First When BIOS boot. Initialize the Heap Manager.
    HeapCallback.allocInstFxn = 'osalHeapAllocFxn'; // Call for allocating a buffer
    HeapCallback.freeInstFxn = 'osalHeapFreeFxn'; // Call for Freeing a buffer
    HeapCallback.getStatsInstFxn = 'osalHeapGetStatsFxn'; // Return Statistic on the Heap.
    HeapCallback.isBlockingInstFxn = 'osalHeapIsBlockingFxn'; // Return TRUE: This heap is always blocking ('Hwi Gate' like )

    /* ================ POSIX configuration ================ */
    const POSIX = scripting.addModule("/ti/posix/tirtos/Settings");

    /* ================ Clock configuration ================ */
    const Clock         = scripting.addModule("/ti/sysbios/knl/Clock", {}, false);
    /*
    * When using Power and calibrateRCOSC is set to true, this should be set to 10.
    * The timer used by the Clock module supports TickMode_DYNAMIC. This enables us
    * to set the tick period to 10 us without generating the overhead of additional
    * interrupts.
    *
    * Note: The calibrateRCOSC parameter is set within the Power configuration
    *     structure in the "Board.c" file.
    */
    Clock.tickPeriod = 10;
    Clock.swiPriority = 5;


    /* ================ Hwi configuration ================ */
    const Hwi           = scripting.addModule("/ti/sysbios/family/arm/m3/Hwi", {}, false);
    /*
    * Checks for Hwi (system) stack overruns while in the Idle loop.
    *
    * Pick one:
    *  - true (default)
    *      Checks the top word for system stack overflows during the idle loop and
    *      raises an Error if one is detected.
    *  - false
    *      Disabling the runtime check improves runtime performance and yields a
    *      reduced flash footprint.
    */
    //Hwi.checkStackFlag = true;
    Hwi.checkStackFlag = false;

    /*
    * The following options alter the system's behavior when a hardware exception
    * is detected.
    *
    * Pick one:
    *  - Hwi.enableException = true
    *      This option causes the default Hwi.excHandlerFunc function to fully
    *      decode an exception and dump the registers to the system console.
    *      This option raises errors in the Error module and displays the
    *      exception in ROV.
    *  - Hwi.enableException = false
    *      This option reduces code footprint by not decoding or printing the
    *      exception to the system console.
    *      It however still raises errors in the Error module and displays the
    *      exception in ROV.
    *  - Hwi.excHandlerFunc = null
    *      This is the most aggressive option for code footprint savings; but it
    *      can difficult to debug exceptions. It reduces flash footprint by
    *      plugging in a default while(1) trap when exception occur. This option
    *      does not raise an error with the Error module.
    */
    //Hwi.enableException = true;
    Hwi.enableException = false;
    //Hwi.excHandlerFunc = null;

    /*
    * Enable hardware exception generation when dividing by zero.
    *
    * Pick one:
    *  - 0 (default)
    *      Disables hardware exceptions when dividing by zero
    *  - 1
    *      Enables hardware exceptions when dividing by zero
    */
    //Hwi.nvicCCR.DIV_0_TRP = 0;
    //Hwi.nvicCCR.DIV_0_TRP = 1;

    /*
    * Starting address to place the interrupt vector table.
    * Note: This is currently placed in RAM to allow for interrupts to be configured at runtime.
    */

    /* ================ Idle configuration ================ */
    const Idle    = scripting.addModule("/ti/sysbios/knl/Idle", {}, false);
    /*
    * The Idle module is used to specify a list of functions to be called when no
    * other tasks are running in the system.
    *
    * Functions added here will be run continuously within the idle task.
    *
    * Function signature:
    *     Void func(Void);
    */
    const powerIdle = Idle.addInstance();
    powerIdle.$name = "powerIdle";
    powerIdle.idleFxn = "Power_idleFunc";
    // BLE project_zero example Idle function
    const uartIdle = Idle.addInstance();
    uartIdle.$name = "uartLog";
    uartIdle.idleFxn = "uartLog_flush";

    /* ================ Semaphore configuration ================ */
    var Semaphore = scripting.addModule("/ti/sysbios/knl/Semaphore", {}, false);
    /*
    * Enables global support for Task priority pend queuing.
    *
    * Pick one:
    *  - true (default)
    *      This allows pending tasks to be serviced based on their task priority.
    *  - false
    *      Pending tasks are services based on first in, first out basis.
    */
    //Semaphore.supportsPriority = true;
    Semaphore.supportsPriority = false;

    /*
    * Allows for the implicit posting of events through the semaphore,
    * disable for additional code saving.
    *
    * Pick one:
    *  - true
    *      This allows the Semaphore module to post semaphores and events
    *      simultaneously.
    *  - false (default)
    *      Events must be explicitly posted to unblock tasks.
    *
    //Semaphore.supportsEvents = true;
    Semaphore.supportsEvents = false;


    /* ================ Swi configuration ================ */
    const Swi = scripting.addModule("/ti/sysbios/knl/Swi", {}, false);
    /*
    * A software interrupt is an object that encapsulates a function to be
    * executed and a priority. Software interrupts are prioritized, preempt tasks
    * and are preempted by hardware interrupt service routines.
    *
    * This module is included to allow Swi's in a users' application.
    */
    /*
    * Reduce the number of swi priorities from the default of 16.
    * Decreasing the number of swi priorities yields memory savings.
    */
    Swi.numPriorities = 6;


    /* ================ System configuration ================ */
    const System = scripting.addModule("/ti/sysbios/runtime/System", {}, false);
    /*
    * The Abort handler is called when the system exits abnormally.
    *
    * Pick one:
    *  - System.abortStd (default)
    *      Call the ANSI C Standard 'abort()' to terminate the application.
    *  - System.abortSpin
    *      A lightweight abort function that loops indefinitely in a while(1) trap
    *      function.
    *  - A custom abort handler
    *      A user-defined function. See the System module documentation for
    *      details.
    */
    //System.abortFxn = "System_abortStd";
    System.abortFxn = "System_abortSpin";
    //System.abortFxn = "myAbortSystem";

    /*
    * The Exit handler is called when the system exits normally.
    *
    * Pick one:
    *  - System.exitStd (default)
    *      Call the ANSI C Standard 'exit()' to terminate the application.
    *  - System.exitSpin
    *      A lightweight exit function that loops indefinitely in a while(1) trap
    *      function.
    *  - A custom exit function
    *      A user-defined function. See the System module documentation for
    *      details.
    */
    //System.exitFxn = "System_exitStd";
    System.exitFxn = "System_exitSpin";
    //System.exitFxn = "myExitSystem";

    /*
    * Minimize exit handler array in the System module. The System module includes
    * an array of functions that are registered with System_atexit() which is
    * called by System_exit(). The default value is 8.
    */
    //System.maxAtexitHandlers = 2;

    /*
    * Enable System_printf() to display floats.
    */
    System.extendedFormats = "%f";

    /*
    * The System.SupportModule defines a low-level implementation of System
    * functions such as System_printf(), System_flush(), etc.
    *
    * Pick one pair:
    *  - SysMin
    *      This module maintains an internal configurable circular buffer that
    *      stores the output until System_flush() is called.
    *      The size of the circular buffer is set via SysMin.bufSize.
    *  - SysCallback
    *      SysCallback allows for user-defined implementations for System APIs.
    *      The SysCallback support proxy has a smaller code footprint and can be
    *      used to supply custom System_printf services.
    *      The default SysCallback functions point to stub functions. See the
    *      SysCallback module's documentation.
    */
    //const SysMin = scripting.addModule("/ti/sysbios/runtime/SysMin");
    //SysMin.bufSize = 1024;
    //System.supportModule = "SysMin";
    const SysCallback = scripting.addModule("/ti/sysbios/runtime/SysCallback");
    System.supportModule = "SysCallback";
    //SysCallback.abortFxn = "myUserAbort";
    //SysCallback.exitFxn  = "myUserExit";
    //SysCallback.flushFxn = "myUserFlush";
    //SysCallback.putchFxn = "myUserPutch";
    //SysCallback.readyFxn = "myUserReady";


    /* ================ Error configuration ================ */
    const Error = scripting.addModule("/ti/sysbios/runtime/Error");

    /*
    * The Error policy that is called when there is an error.
    *
    * Pick one:
    *  - Error_SPIN
    *      This is the most light-weight policy that loops indefinitely in a
    *      while(1) trap function.
    *  - Error_UNWIND
    *      This error policy will unwind the call and return to the caller.
    *  - Error_TERMINATE
    *      This error policy will call System_abort() when the error is raised.
    */
    Error.policy = "Error_SPIN";

    /*
    * Pick one:
    *  - true
    *      The details of the error will be printed using System_printf(). This
    *      results in a printf() implementation always being pulled into the
    *      application and adds several kB of flash overhead.
    *  - false
    *      The details of the error will not be printed out.
    */
    Error.printDetails = false;


    /* ================ Task configuration ================ */
    const Task = scripting.addModule("/ti/sysbios/knl/Task", {}, false);
    /*
    * Check task stacks for overflow conditions.
    *
    * Pick one:
    *  - true (default)
    *      Enables runtime checks for task stack overflow conditions during
    *      context switching ("from" and "to")
    *  - false
    *      Disables runtime checks for task stack overflow conditions.
    *
    //Task.checkStackFlag = true;
    Task.checkStackFlag = false;

    /*
    * Set the default task stack size when creating tasks.
    *
    * The default is dependent on the device being used. Reducing the default stack
    * size yields greater memory savings.
    */
    Task.defaultStackSize = 512;

    /*
    * Enables the idle task.
    *
    * Pick one:
    *  - true (default)
    *      Creates a task with priority of 0 which calls idle hook functions. This
    *      option must be set to true to gain power savings provided by the Power
    *      module.
    *  - false
    *      No idle task is created. This option consumes less memory as no
    *      additional default task stack is needed.
    *      To gain power savings by the Power module without having the idle task,
    *      add Idle.run as the Task.allBlockedFunc.
    */
    Task.enableIdleTask = true;
    //Task.enableIdleTask = false;
    //Task.allBlockedFunc = Idle.run;

    /*
    * If Task.enableIdleTask is set to true, this option sets the idle task's
    * stack size.
    *
    * Reducing the idle stack size yields greater memory savings.
    */
    Task.idleTaskStackSize = 768;

    /*
    * Reduce the number of task priorities.
    * The default is 16.
    * Decreasing the number of task priorities yield memory savings.
    */
    Task.numPriorities = 6;


    /* ================ Additional configuration ================ */
    /*
    * Add a few other commonly used modules.
    */
    const Event = scripting.addModule("/ti/sysbios/knl/Event");
    const Mailbox = scripting.addModule("/ti/sysbios/knl/Mailbox");
    const Timestamp = scripting.addModule("/ti/sysbios/runtime/Timestamp");
    /* ================ GateMutexPri configuration ================ */
    var GateMutexPri = scripting.addModule("/ti/sysbios/gates/GateMutexPri");
}
